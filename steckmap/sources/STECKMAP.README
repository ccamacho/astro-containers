The STECKMAP package is written in yorick. You will thus need to first
install yorick (http://www.maumae.net/yorick/doc/).
This should in principle be
painless, especially using the pre-compiled binary distributions. You
should even be able to install it through fink (for Mac) or the
linux equivalent. Also yorick is very light (much lighter than the
STECKMAP package itself) so you wont have to worry about disk space.

INSTALLING:

- (1) install yorick. It is important for this version that yorick be installed in the Yorick/ directory such as:
<user-home>/Yorick/
Successful installation should result in the yorick executable to have a full path similar to:
<user-home>/Yorick/yorick-1.6/yorick/yorick
(for yorick-1.6 that is, and yorick-??? for more recent versions)

this note provides few guidelines for installing
yorick. Refer to yorick's README for more.
I however recommend using yorick through emacs. Follow the yorick.el instructions to do so. You will need to make a straightforward modification of your ~/.emacs. and inside yorick.el dont forget to provide the full path to the yorick executable (search for the string "yorick-executable-name" and replace the adjacent string "yorick" with the full path to the executable).
You can check if yorick is correctly installed by typing
yorick
> include, "demo3.i"
> demo3

- (2) in your Yorick directory ($HOME/Yorick/), untar the STECKMAP archive
tar -xvf STECKMAP.tar
Some routines use the environment variable HOME to define absolute paths to some objects, so be sure it is correctly defined by typing in a shell:
echo $HOME

- (3) The last step consists in putting a few gist files (they define plotting formats) in the
proper location for yorick to find them. 
yorick's defaut directory for these is:
$HOME/Yorick/yorick-?version_number?/g/

so copy the Gist files extracted from the STECKMAP archive into this directory by typing:
cp -r $HOME/Yorick/STECKMAP/Gist/*
$HOME/Yorick/yorick-?version_number?/g/

Congratulations, you are done with the installation.


RUNNING STECKMAP:

- launch yorick by typing "yorick" on the shell command line
if yorick does not launch, go back to (1)

- once, yorick is launched, load STECKMAP by typing 
include, "STECKMAP/Pierre/POP/sfit.i"


GET STARTED WITH AN EXAMPLE:

You will find a couple of example data in Yorick/Pierre/POP/EXAMPLES/.
They are provided in order to give the user a taste of what can be done
and how to proceed. Follow this small tutorial.

STECKMAP is a tool package aiming at constraining the stellar content and
kinematics from galaxy spectra. To do so, you need two things:
* DATA
* Models against which to compare your data

The first thing to do is to get your data in a format that sfit will
understand, and that provides all necessary meta-data (SNR, error
vectors, masks...). Then
you will need to
create a basis of SSPs that will be
combined to match your data. Then you will want to compare your data with
the models. Routines are provided for these 3 steps. They form the core of
STECKMAP.

I - CONVERTING THE DATA: .fits to .pdb
yorick native binary file format is .pdb. 
It is however very easy to convert your .fits spectra into .pdb using the
convert_all routine. It should be able to handle all the properly
formatted fits spectra (i.e.
having the proper keywords set, especially those defining wavelengths), 1d
or 2d. 

Lets take an example. See the path and name of an example file I set up by
typing
> fV
fV is just a variable storing the path and name of the example file. To
make things easier, it is loaded by default.
Convert the example file using convertVAKU,
> a=convert_all(fV)

this will create the .pdb file, plot the data, and write the redshdift of
the example galaxy if it is supplied in the fits keywords. Otherwise it
will just assume 0, as in this case.
Note that it will plot the 2d plate and the spectrum obtained by summing
the whole 2d spectrum in the spatial direction. This is the default
behaviour of convert_all.

II - GENERATE A SSP BASIS

A basis is a structure as defined in "Pierre/POP/base_struct.i". This structure contains the sequence of SSPs in time and metallicity. As such, it is a data cube. The structure contains this cube and also the wavelengths, the resolution, the metallicity scale, and the ages of wach element of the basis.

To generate a basis, use the function bRbasis3:
> b=bRbasis3()

This will call bRbasis3 with all the defaults arguments (type >
help,bRbasis to get help and see information about the various arguments and their default values). Here the default is a basis with 10 age bins from 10Myr to 20 Gyr with Salpeter IMF and Padova tracks. It is flux-normalized by default (see the STECMAP paper for details). It is generated by PEGASE-HR so R=10000 and the wavelength coverage is 4000-6900 A. All these values can of course be changed when calling bRbasis.

To have an idea of the looks of the  basis you just generated, type
> ws  
this is to clear the display
> plb, b.flux(,,1),b.wave
This will result in a nice plot of the basis for the first metallicity of the basis. It can be printed by typing:
> b.met(1) 
since the metallicities are stored in b.met. Note that for computational reasons, the metallicities are renormalized. Hence, you can read the original metallicity of the first constant-metallicity slice of the SSP cube b.flux(,,1) by typing:
> Zrescalem1(b.met(1))
it should be 0.05.

We are now set for the big game.


III - FIT THE DATA

The fitting engine is called with the sfit command, which takes as arguments, the data, the basis and a bunch of options. Type 
> help,sfit
to see the current documentation for sfit.
To fit the data, the structure of which is stored in the variable a, using the SSP basis, the structure of which is stored in the variable b, type:
> x=sfit(a,b)
If you get a message of the kind "skipping..." then it means you already have a results file for this data. Force the computation by adding the option noskip=1:
> x=sfit(a,b,noskip=1,sav=1)
The additional option sav=1 tells sfit to save the results.
You will see columns of number (just like in Matrix) showing the minimization process of the objective function.
Check the displays to see the data (black), the fit (red), and the mask (blue).
This doesn't look very good, especially since the models are at much higher resolution than the data. This will allow us to investigate the kinematics of the galaxy. The LOSVD research features of sfit will be set on by the option kin=1:
> x=sfit(a,b,kin=1,noskip=1,sav=1)

This is already better. But now the residuals seem to be dominated by some flux calibration error. By default, the extinction law is taken from Calzetti 1999, which does not account for possible calibration errors. A special way to deal with that has been introduced as NPEC. Set it on by using the option epar=3. The number of anchor points is specified by nde. nde=10 by default. Type:
> x=sfit(a,b,kin=1,epar=3,nde=100,noskip=1,sav=1)

Woohoo! The residuals are cut by 2 or 3.

You can check in the directory $HOME/Yorick/STECKMAP/Pierre/POP/EXAMPLES/
that the folowing files have been produced:
a .pdb, which is the .fits converted into .pdb...
a .res-SAD.txt file, a text file containing the stellar age distribution
(SAD) derived for this example data. 
a .res-MASS.txt file, the same with the masses produced in each time bin
(it is only relatively normalized so far, so they are not absolute masses)
a .res-SFR.txt file, containing the SFR as a function of lookback time
(it is also not absolutely normalized).
a .res-AMR.txt file, giving the age-metallicity relation of the observed
population, in the form of the metallicity for each age bin.

Work is in progress to produce shell command lines scripts, in order to eventually have the yorick part totally hidden, and the user issuing exclusively shell commands.
I am currently working on a GUI using ytk, a yorick interface for tcl. It
is going to be niiiiice.

Pierre OCVIRK, 6th of december 2006

